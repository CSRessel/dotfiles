overrideIfInstalled () {
    type "$2" >/dev/null 2>&1 && alias "$1"="$2"
}

# overrideIfInstalled nori $HOME/.local/bin/nori

overrideIfInstalled vim lvim
overrideIfInstalled kc kubectl
overrideIfInstalled kx kubectx
overrideIfInstalled cat bat
# overrideIfInstalled grep rg
overrideIfInstalled fd fdfind

chezmoiAliased() {
    if [ $# -eq 1 ]; then
        if [ "$1" = "st" ]; then
            chezmoi status
        elif [ "$1" = "di" ]; then
            chezmoi diff
        else
            chezmoi "$@"
        fi
    else
        chezmoi "$@"
    fi
}
alias ch=chezmoiAliased

alias cp="cp -i" # confirm before overwriting something
alias df="df -h" # human-readable sizes
alias more="less"
alias k9s="k9s --logoless"

{{ if eq .chezmoi.username "clifford" }}
{{- /* only on personal machine */ -}}

alias kubectl="minikube kubectl --"
alias kc="minikube kubectl --"
overrideIfInstalled docker podman
overrideIfInstalled docker-compose podman-compose

alias obstatus="rclone check --filter '- .git/**' gdrive:/knowledgebase /home/clifford/Documents/knowledgebase/"
alias obpull="rclone sync --filter '- .git/**' -i gdrive:/knowledgebase /home/clifford/Documents/knowledgebase/"
alias obpush="rclone sync --filter '- .git/**' -i /home/clifford/Documents/knowledgebase/ gdrive:/knowledgebase"

{{- end }}

alias network-displays="G_MESSAGES_DEBUG=all flatpak run org.gnome.NetworkDisplays"

watchpytest () {
    GLOB=${1:-"./"}
    # Using fd-find syntax
    fdfind . -e py "$GLOB" | entr -d -s "pytest $GLOB"
}

alias mitm="uvx mitmproxy"
alias ai="bunx opencode-ai run -m 'opencode/kimi-k2.5-free'" # currently free, and very fast

{{- /* Trash directory support for safe rm */ -}}
{{ $hasTrash := false }}
{{ $trashCommand := "" }}
{{ $trashDir := joinPath .chezmoi.homeDir ".local/share/Trash" }}

{{- if lookPath "gio" -}}
{{ $hasTrash = true }}
{{ $trashCommand = "gio trash" }}
{{- else if lookPath "trash-put" -}}
{{ $hasTrash = true }}
{{ $trashCommand = "trash-put" }}
{{- else if stat $trashDir -}}
{{ $hasTrash = true }}
{{ $trashCommand = "custom_trash" }}
{{- end }}

{{ if $hasTrash }}
# Safe rm wrapper - moves files to trash instead of permanent deletion
TRASH_DIR="{{ $trashDir }}"

{{ if eq $trashCommand "custom_trash" }}
# Custom trash implementation for systems without gio/trash-cli
custom_trash() {
    local trash_files="$TRASH_DIR/files"
    local trash_info="$TRASH_DIR/info"
    
    mkdir -p "$trash_files" "$trash_info"
    
    for file in "$@"; do
        if [ ! -e "$file" ]; then
            echo "trash: cannot trash '$file': No such file or directory" >&2
            continue
        fi
        
        local basename=$(basename "$file")
        local timestamp=$(date +%Y-%m-%dT%H:%M:%S)
        local abs_path=$(realpath "$file")
        
        # Handle name collisions
        local dest_name="$basename"
        local counter=1
        while [ -e "$trash_files/$dest_name" ]; do
            dest_name="${basename}.${counter}"
            counter=$((counter + 1))
        done
        
        # Move file to trash
        mv "$file" "$trash_files/$dest_name"
        
        # Create .trashinfo metadata
        cat > "$trash_info/${dest_name}.trashinfo" <<EOF
[Trash Info]
Path=$abs_path
DeletionDate=$timestamp
EOF
    done
}
{{ end }}

safe_rm() {
    local force_delete=0
    local trash_args=()
    
    # Check for --really-delete flag to bypass trash
    for arg in "$@"; do
        if [ "$arg" = "--really-delete" ] || [ "$arg" = "--force-delete" ]; then
            force_delete=1
        else
            trash_args+=("$arg")
        fi
    done
    
    if [ $force_delete -eq 1 ]; then
        command rm "${trash_args[@]}"
    else
        {{ $trashCommand }} "${trash_args[@]}"
    fi
}

# Alias rm to safe_rm (users can still use \rm or command rm to bypass)
alias rm='safe_rm'
{{ end }}

# Fuzzy finders (fzf vim, fzf make, fzf git log)
alias fvim="fd --type f --hidden --exclude .git --print0 | fzf-tmux -p -- --read0 --print0 --exit-0 | xargs -r -0 lvim"
fmake() {
  local target=$(make -qp | awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ {split($1,A,/ /);for(i in A)print A[i]}' | sort -u | fzf --header="Select Makefile Target")
  [ -n "$target" ] && make "$target"
}
flog() {
    local selection=$(
      git lo --color=always "$@" | \
        fzf --no-multi --ansi --no-sort --no-height \
            --preview "echo {} | grep -o '[a-f0-9]\{7\}' | head -1 |
                       xargs -I@ sh -c 'git show --color=always @'"
    )
    if [[ -n $selection ]]; then
        local commit=$(echo "$selection" | sed 's/^[* |]*//' | awk '{print $1}' | tr -d '\n')
        git show $commit
    fi
}
